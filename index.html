<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense Game - Fixed</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        
        #gameContainer {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        #gameCanvas {
            border: 3px solid #fff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            background: #2d5a27;
        }
        
        #gameUI {
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            min-width: 200px;
        }
        
        .tower-button {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .tower-button:hover {
            background: linear-gradient(45deg, #45a049, #4CAF50);
            transform: translateY(-2px);
        }
        
        .tower-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        #gameStats {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        #waveButton {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            padding: 15px;
            font-size: 16px;
            font-weight: bold;
        }
        
        #waveButton:hover {
            background: linear-gradient(45deg, #ee5a52, #ff6b6b);
        }
    </style>
</head>
<body>
    <h1>üè∞ Tower Defense</h1>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="gameUI">
            <div id="gameStats">
                <div class="stat">
                    <span>üí∞ Gold:</span>
                    <span id="goldDisplay">400</span>
                </div>
                <div class="stat">
                    <span>‚ù§Ô∏è Lives:</span>
                    <span id="livesDisplay">100</span>
                </div>
                <div class="stat">
                    <span>üåä Wave:</span>
                    <span id="waveDisplay">1</span>
                </div>
                <div class="stat">
                    <span>üó∫Ô∏è Map:</span>
                    <span id="mapDisplay">Bridge</span>
                </div>
                <div class="stat">
                    <span>üëπ Enemies:</span>
                    <span id="enemiesDisplay">0</span>
                </div>
            </div>
            
            <h3>üèóÔ∏è Build Towers</h3>
            <button class="tower-button" id="wizardTower" onclick="selectTower('wizard')">
                üßô‚Äç‚ôÇÔ∏è Elemental Wizard (80g)
            </button>
            <button class="tower-button" id="archerTower" onclick="selectTower('archer')">
                üèπ Elven Archer (60g)
            </button>
            <button class="tower-button" id="ninjaTower" onclick="selectTower('ninja')">
                ü•∑ Shadow Ninja (90g)
            </button>
            <button class="tower-button" id="cannonTower" onclick="selectTower('cannon')">
                üíé Crystal Cannon (120g)
            </button>
            <button class="tower-button" id="catapultTower" onclick="selectTower('catapult')">
                ü™® Catapult (110g)
            </button>
            <button class="tower-button" id="heroTower" onclick="selectTower('hero')">
                ‚öîÔ∏è Hero (200g) - UNIQUE
            </button>
            
            <button id="waveButton" class="tower-button" onclick="startWave()">
                üöÄ Start Wave
            </button>
            
            <div id="autoWaveContainer" style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; border: 2px solid transparent; transition: all 0.3s;">
                <label style="display: flex; align-items: center; cursor: pointer; font-weight: bold;">
                    <input type="checkbox" id="autoWaveToggle" onchange="toggleAutoWave()" style="margin-right: 10px; transform: scale(1.3);">
                    <span id="autoWaveLabel">üîÑ Auto-start waves</span>
                </label>
                <div id="autoWaveStatus" style="font-size: 11px; margin-top: 5px; opacity: 0.8;">
                    Manual mode - Click to start each wave
                </div>
            </div>
            
            <div id="upgradeSection" style="display: none; margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 5px;">
                <h4>‚¨ÜÔ∏è Tower Options</h4>
                <div id="selectedTowerInfo"></div>
                <button class="tower-button" id="upgradeButton" onclick="upgradeTower()">
                    Upgrade (Cost: 0g)
                </button>
                <button class="tower-button" id="sellButton" onclick="sellTower()" style="background: linear-gradient(45deg, #ff6b6b, #ee5a52);">
                    üí∞ Sell Tower
                </button>
                <button class="tower-button" onclick="deselectTower()" style="background: #666;">
                    Cancel
                </button>
            </div>
            
            <div style="margin-top: 20px; font-size: 11px; opacity: 0.8;">
                <p>üí° <strong>How to Play:</strong></p>
                <p>‚Ä¢ Click tower type, then click to place</p>
                <p>‚Ä¢ Click towers to upgrade (4 levels max)</p>
                <p>‚Ä¢ Defend against enemy waves!</p>

                <p><strong>üèπ Enemy Types & Immunities:</strong></p>
                <p>üëæ Goblin - Magic resistant, immune to üßô‚Äç‚ôÇÔ∏è wizard</p>
                <p>üèÉ Scout - Too fast, immune to ü•∑ ninja</p>
                <p>üõ°Ô∏è Armored Orc - Heavy armor, immune to üèπ archer</p>
                <p>ü¶Ö Wyvern - Too agile, immune to üíé cannon</p>
                <p>üëπ Demon Lord - Boss, no immunities (10 lives!)</p>

                <p><strong>üí∞ Tower Management:</strong></p>
                <p>‚Ä¢ Click towers to upgrade or sell</p>
                <p>‚Ä¢ Sell value = 50% of total investment</p>
                <p>‚Ä¢ üõ°Ô∏è icon shows immunity in effect</p>
                <p>‚Ä¢ ‚Üë icon shows hero buff is active</p>

                <p><strong>üóº Special Towers:</strong></p>
                <p>ü™® Catapult - Heavy damage, gains fire DoT</p>
                <p>‚öîÔ∏è Hero - UNIQUE! Buffs nearby towers</p>

                <p><strong>‚öîÔ∏è Strategy Guide:</strong></p>
                <p>üßô‚Äç‚ôÇÔ∏è vs Scouts, Orcs, Wyverns, Boss</p>
                <p>üèπ vs Goblins, Scouts, Wyverns, Boss</p>
                <p>ü•∑ vs Goblins, Orcs, Wyverns, Boss</p>
                <p>üíé vs Goblins, Scouts, Orcs, Boss</p>
                <p>ü™® vs All (fire damage at lvl 2+)</p>
            </div>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let game = {
            gold: 400,
            lives: 100,
            wave: 1,
            selectedTowerType: null,
            selectedTowerInstance: null,
            waveActive: false,
            autoWave: false,
            autoWaveCountdown: 0,
            currentMap: 0,
            victory: false,
            heroPlaced: false
        };
        
        // Map definitions with different themes and objectives
        const mapData = [
            {
                name: "üåâ Defend the Bridge",
                description: "Protect the ancient stone bridge from goblin raiders",
                waves: 25,
                objective: "Bridge",
                backgroundColor: '#4CAF50',
                pathColor: '#8B4513',
                pathCenterColor: '#D2691E'
            },
            {
                name: "üèîÔ∏è Mountain Pass",
                description: "Guard the treacherous mountain pass from orc invaders", 
                waves: 25,
                objective: "Pass",
                backgroundColor: '#8D6E63',
                pathColor: '#5D4037',
                pathCenterColor: '#795548'
            },
            {
                name: "üè∞ Defend the Castle",
                description: "Make your final stand at the royal castle gates",
                waves: 50,
                objective: "Castle",
                backgroundColor: '#607D8B',
                pathColor: '#37474F',
                pathCenterColor: '#546E7A'
            }
        ];
        
        let towers = [];
        let enemies = [];
        let projectiles = [];
        
        // Game path (goes to edges)
        const path = [
            {x: 0, y: 300},
            {x: 200, y: 300},
            {x: 300, y: 200},
            {x: 500, y: 200},
            {x: 600, y: 400},
            {x: 800, y: 400}
        ];
        
        // Tower types with upgrade levels
        const towerTypes = {
            wizard: {
                name: "üßô‚Äç‚ôÇÔ∏è Elemental Wizard",
                baseCost: 70,
                upgrades: [
                    { damage: 30, range: 100, fireRate: 1000, color: '#FF6B35', spells: ['fire'] },
                    { damage: 45, range: 110, fireRate: 900, color: '#4B0082', spells: ['fire', 'ice'] },
                    { damage: 70, range: 120, fireRate: 800, color: '#800080', spells: ['fire', 'ice', 'lightning'] },
                    { damage: 110, range: 140, fireRate: 700, color: '#4B0082', spells: ['fire', 'ice', 'lightning', 'wind'] }
                ]
            },
            archer: {
                name: "üèπ Elven Archer",
                baseCost: 50,
                upgrades: [
                    { damage: 25, range: 120, fireRate: 800, color: '#228B22', effect: 'pierce' },
                    { damage: 40, range: 140, fireRate: 700, color: '#006400', effect: 'pierce' },
                    { damage: 65, range: 160, fireRate: 600, color: '#2E8B57', effect: 'pierce' },
                    { damage: 100, range: 180, fireRate: 500, color: '#8FBC8F', effect: 'pierce' }
                ]
            },
            ninja: {
                name: "ü•∑ Shadow Ninja",
                baseCost: 80,
                upgrades: [
                    { damage: 35, range: 70, fireRate: 600, color: '#2F2F2F', effect: 'critical' },
                    { damage: 55, range: 80, fireRate: 550, color: '#1C1C1C', effect: 'critical' },
                    { damage: 85, range: 90, fireRate: 500, color: '#0D0D0D', effect: 'critical' },
                    { damage: 130, range: 100, fireRate: 450, color: '#000000', effect: 'critical' }
                ]
            },
            cannon: {
                name: "üíé Crystal Cannon",
                baseCost: 100,
                upgrades: [
                    { damage: 80, range: 90, fireRate: 2500, color: '#E6E6FA', effect: 'crystal' },
                    { damage: 130, range: 100, fireRate: 2300, color: '#DDA0DD', effect: 'crystal' },
                    { damage: 200, range: 110, fireRate: 2100, color: '#DA70D6', effect: 'crystal' },
                    { damage: 320, range: 120, fireRate: 1900, color: '#FF69B4', effect: 'crystal' }
                ]
            },
            catapult: {
                name: "ü™® Catapult",
                baseCost: 110,
                upgrades: [
                    { damage: 90, range: 130, fireRate: 2800, color: '#8B4513', effect: 'splash', fireDamage: 0 },
                    { damage: 140, range: 140, fireRate: 2600, color: '#A0522D', effect: 'splash', fireDamage: 20 },
                    { damage: 210, range: 150, fireRate: 2400, color: '#CD853F', effect: 'splash', fireDamage: 35 },
                    { damage: 330, range: 160, fireRate: 2200, color: '#D2691E', effect: 'splash', fireDamage: 55 }
                ]
            },
            hero: {
                name: "‚öîÔ∏è Hero",
                baseCost: 200,
                unique: true,
                upgrades: [
                    { damage: 50, range: 100, fireRate: 1200, color: '#FFD700', effect: 'hero', buffRange: 120, buffDamage: 0.15, buffFireRate: 0.10 },
                    { damage: 80, range: 110, fireRate: 1100, color: '#FFA500', effect: 'hero', buffRange: 140, buffDamage: 0.25, buffFireRate: 0.15 },
                    { damage: 120, range: 120, fireRate: 1000, color: '#FF8C00', effect: 'hero', buffRange: 160, buffDamage: 0.35, buffFireRate: 0.20 },
                    { damage: 180, range: 130, fireRate: 900, color: '#FF4500', effect: 'hero', buffRange: 180, buffDamage: 0.50, buffFireRate: 0.25 }
                ]
            }
        };

        // Enemy types with balanced immunities (each tower has one counter)
        const enemyTypes = {
            basic: { 
                name: "üëæ Goblin", baseHealth: 50, baseSpeed: 1.0, color: '#FF6B6B', size: 12, 
                abilities: [], immunities: ['wizard'], liveDamage: 1 // Magic resistant
            },
            fast: { 
                name: "üèÉ Scout", baseHealth: 30, baseSpeed: 1.8, color: '#FFD700', size: 10, 
                abilities: ['speed_boost'], immunities: ['ninja'], liveDamage: 1 // Too fast for ninja
            },
            heavy: { 
                name: "üõ°Ô∏è Armored Orc", baseHealth: 120, baseSpeed: 0.6, color: '#8B4513', size: 16, 
                abilities: ['armor'], immunities: ['archer'], liveDamage: 3 // Armor blocks arrows
            },
            flying: { 
                name: "ü¶Ö Wyvern", baseHealth: 80, baseSpeed: 1.2, color: '#9370DB', size: 14, 
                abilities: ['flying'], immunities: ['cannon'], liveDamage: 2 // Too agile for slow crystals
            },
            boss: { 
                name: "üëπ Demon Lord", baseHealth: 300, baseSpeed: 0.7, color: '#8B0000', size: 20, 
                abilities: ['boss_aura'], immunities: [], liveDamage: 10 // No immunities - all towers work
            }
        };
        
        // Tower class with upgrades
        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.level = 0;
                this.stats = towerTypes[type].upgrades[this.level];
                this.lastFire = 0;
                this.target = null;
                this.isSelected = false;
                this.animationFrame = 0;
            }
            
            upgrade() {
                if (this.level < 3) {
                    const upgradeCost = this.getUpgradeCost();
                    if (game.gold >= upgradeCost) {
                        game.gold -= upgradeCost;
                        this.level++;
                        this.stats = towerTypes[this.type].upgrades[this.level];
                        return true;
                    }
                }
                return false;
            }
            
            getUpgradeCost() {
                if (this.level >= 3) return 0;
                const baseCost = towerTypes[this.type].baseCost;
                return Math.floor(baseCost * (1.5 ** (this.level + 1)));
            }
            
            canUpgrade() {
                return this.level < 3 && game.gold >= this.getUpgradeCost();
            }
            
            update() {
                this.animationFrame++;

                // Calculate buffs from nearby heroes
                this.heroBuff = this.getHeroBuffs();

                // Find closest enemy in range (excluding immune enemies)
                this.target = null;
                let closestDistance = this.stats.range;

                for (let enemy of enemies) {
                    // Skip enemies that are immune to this tower type
                    if (enemy.immunities && enemy.immunities.includes(this.type)) {
                        continue;
                    }

                    const distance = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (distance <= closestDistance) {
                        this.target = enemy;
                        closestDistance = distance;
                    }
                }

                // Calculate effective fire rate with hero buff
                const effectiveFireRate = this.heroBuff ?
                    this.stats.fireRate * (1 - this.heroBuff.fireRate) :
                    this.stats.fireRate;

                // Fire at target
                if (this.target && Date.now() - this.lastFire > effectiveFireRate) {
                    this.fire();
                    this.lastFire = Date.now();
                }
            }

            getHeroBuffs() {
                // Find nearby hero and get its buffs
                for (let tower of towers) {
                    if (tower.type === 'hero' && tower !== this) {
                        const distance = Math.sqrt((this.x - tower.x) ** 2 + (this.y - tower.y) ** 2);
                        if (distance <= tower.stats.buffRange) {
                            return {
                                damage: tower.stats.buffDamage,
                                fireRate: tower.stats.buffFireRate
                            };
                        }
                    }
                }
                return null;
            }
            
            fire() {
                if (!this.target) return;

                // Calculate effective damage with hero buff
                const effectiveDamage = this.heroBuff ?
                    Math.floor(this.stats.damage * (1 + this.heroBuff.damage)) :
                    this.stats.damage;

                // Determine spell type for wizard
                let spellType = 'normal';
                if (this.type === 'wizard' && this.stats.spells) {
                    const spells = this.stats.spells;
                    spellType = spells[Math.floor(Math.random() * spells.length)];
                }

                // Catapult fire damage
                let fireDamage = 0;
                if (this.type === 'catapult' && this.stats.fireDamage) {
                    fireDamage = this.stats.fireDamage;
                }

                projectiles.push({
                    x: this.x,
                    y: this.y,
                    targetX: this.target.x,
                    targetY: this.target.y,
                    target: this.target,
                    damage: effectiveDamage,
                    fireDamage: fireDamage,
                    speed: 8,
                    spellType: spellType,
                    towerType: this.type
                });
            }
            
            draw() {
                const size = 15 + (this.level * 2);
                
                // Tower base
                ctx.fillStyle = this.stats.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Tower symbol
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `${14 + this.level}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let symbol = '';
                if (this.type === 'wizard') {
                    // Show current spell for wizard
                    const spells = this.stats.spells || ['fire'];
                    const spellIndex = Math.floor(this.animationFrame / 60) % spells.length;
                    const currentSpell = spells[spellIndex];

                    switch(currentSpell) {
                        case 'fire': symbol = 'üî•'; break;
                        case 'ice': symbol = '‚ùÑÔ∏è'; break;
                        case 'lightning': symbol = '‚ö°'; break;
                        case 'wind': symbol = 'üí®'; break;
                        default: symbol = 'üßô‚Äç‚ôÇÔ∏è'; break;
                    }
                } else {
                    switch(this.type) {
                        case 'archer': symbol = 'üèπ'; break;
                        case 'ninja': symbol = 'ü•∑'; break;
                        case 'cannon': symbol = 'üíé'; break;
                        case 'catapult': symbol = 'ü™®'; break;
                        case 'hero': symbol = '‚öîÔ∏è'; break;
                    }
                }
                ctx.fillText(symbol, this.x, this.y);

                // Show hero buff range
                if (this.type === 'hero') {
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.buffRange, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Show buff indicator if tower is buffed by hero
                if (this.heroBuff && this.type !== 'hero') {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '12px Arial';
                    ctx.fillText('‚Üë', this.x + size + 5, this.y - size - 5);
                }
                
                // Level stars
                if (this.level > 0) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '10px Arial';
                    for (let i = 0; i < this.level; i++) {
                        ctx.fillText('‚òÖ', this.x - 8 + (i * 5), this.y - size - 5);
                    }
                }
                
                // Range indicator when selected
                if (this.isSelected) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.range, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Upgrade indicator
                    if (this.canUpgrade()) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                        ctx.fillRect(this.x - 25, this.y + size + 5, 50, 15);
                        ctx.fillStyle = '#000';
                        ctx.font = '10px Arial';
                        ctx.fillText(`‚Üë ${this.getUpgradeCost()}g`, this.x, this.y + size + 12);
                    }
                }
            }
        }
        
        // Enhanced Enemy class
        class Enemy {
            constructor(type, wave) {
                this.type = type;
                this.enemyData = enemyTypes[type];
                
                // Scale stats based on wave (balanced scaling)
                const waveMultiplier = 1 + (wave * 0.15);
                const healthMultiplier = 1 + (wave * 0.25); // Reduced for better balance
                
                this.health = Math.floor(this.enemyData.baseHealth * healthMultiplier);
                this.maxHealth = this.health;
                this.speed = this.enemyData.baseSpeed * Math.min(waveMultiplier, 2.5);
                this.reward = 15 + Math.floor(wave * 2); // Better base reward for economy
                
                // Position and movement
                this.pathIndex = 0;
                this.x = path[0].x;
                this.y = path[0].y;
                this.progress = 0;
                
                // Special abilities and immunities
                this.abilities = [...this.enemyData.abilities];
                this.immunities = [...this.enemyData.immunities];
                this.liveDamage = this.enemyData.liveDamage;
                this.speedBoostTimer = 0;
                this.armor = this.abilities.includes('armor') ? Math.floor(wave * 0.5) : 0;
                
                // Animation
                this.animationFrame = 0;

                // Fire damage over time
                this.burning = false;
                this.burnDamage = 0;
                this.burnDuration = 0;
            }
            
            update() {
                if (this.pathIndex >= path.length - 1) return false;

                this.animationFrame++;

                // Apply burning damage over time
                if (this.burning && this.burnDuration > 0) {
                    this.health -= this.burnDamage / 60; // Damage per frame (60 fps)
                    this.burnDuration--;
                    if (this.burnDuration <= 0) {
                        this.burning = false;
                    }
                }
                
                // Speed boost ability (for scouts)
                let currentSpeed = this.speed;
                if (this.abilities.includes('speed_boost')) {
                    this.speedBoostTimer++;
                    if (this.speedBoostTimer >= 180 && this.speedBoostTimer < 240) { // Boost for 1 second every 3 seconds
                        currentSpeed *= 2;
                    }
                    if (this.speedBoostTimer >= 240) {
                        this.speedBoostTimer = 0;
                    }
                }
                
                // Boss aura effect (makes nearby enemies faster)
                if (this.abilities.includes('boss_aura')) {
                    for (let enemy of enemies) {
                        if (enemy !== this) {
                            const distance = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                            if (distance <= 80) {
                                enemy.speed = Math.min(enemy.speed * 1.001, enemy.enemyData.baseSpeed * 2);
                            }
                        }
                    }
                }
                
                const current = path[this.pathIndex];
                const next = path[this.pathIndex + 1];
                
                const dx = next.x - current.x;
                const dy = next.y - current.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                this.progress += currentSpeed / distance;
                
                if (this.progress >= 1) {
                    this.pathIndex++;
                    this.progress = 0;
                    
                    if (this.pathIndex >= path.length - 1) {
                        // Different enemies cause different amounts of damage
                        game.lives -= this.liveDamage;
                        return false;
                    }
                }
                
                const current2 = path[this.pathIndex];
                const next2 = path[this.pathIndex + 1];
                
                this.x = current2.x + (next2.x - current2.x) * this.progress;
                this.y = current2.y + (next2.y - current2.y) * this.progress;
                
                return true;
            }
            
            draw() {
                const size = this.enemyData.size + Math.floor(game.wave * 0.3); // Grow with waves
                
                // Special aura for boss enemies
                if (this.abilities.includes('boss_aura')) {
                    const auraSize = size + Math.sin(this.animationFrame * 0.1) * 4;
                    ctx.fillStyle = 'rgba(139, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, auraSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Flying enemies have a shadow
                if (this.abilities.includes('flying')) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(this.x + 2, this.y + 8, size * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Main enemy body
                ctx.fillStyle = this.enemyData.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Armor indicator for armored enemies
                if (this.abilities.includes('armor') && this.armor > 0) {
                    ctx.strokeStyle = '#C0C0C0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size + 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Enemy type emoji
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `${Math.max(10, size - 2)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let emoji = 'üëæ'; // Default
                switch(this.type) {
                    case 'basic': emoji = 'üëæ'; break;
                    case 'fast': emoji = 'üèÉ'; break;
                    case 'heavy': emoji = 'üõ°Ô∏è'; break;
                    case 'flying': emoji = 'ü¶Ö'; break;
                    case 'boss': emoji = 'üëπ'; break;
                }
                
                const yOffset = this.abilities.includes('flying') ? -3 : 0;
                ctx.fillText(emoji, this.x, this.y + yOffset);
                
                // Effect indicators
                if (this.abilities.includes('speed_boost') && this.speedBoostTimer >= 180 && this.speedBoostTimer < 240) {
                    ctx.fillText('üí®', this.x - size - 8, this.y - 15);
                }

                // Burning indicator
                if (this.burning) {
                    ctx.fillStyle = '#FF4500';
                    ctx.font = '14px Arial';
                    ctx.fillText('üî•', this.x + size + 5, this.y - 10);
                }
                
                // Immunity indicators (show shield when being targeted by immune tower)
                for (let tower of towers) {
                    if (tower.target === this && this.immunities.includes(tower.type)) {
                        ctx.fillStyle = '#FFD700';
                        ctx.font = '12px Arial';
                        ctx.fillText('üõ°Ô∏è', this.x + size + 5, this.y - 10);
                        break;
                    }
                }
                
                // Health bar
                const barWidth = Math.max(20, size * 1.2);
                const barHeight = 4;
                const healthPercent = this.health / this.maxHealth;
                
                // Background
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(this.x - barWidth/2, this.y - size - 12, barWidth, barHeight);
                
                // Health
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(this.x - barWidth/2, this.y - size - 12, barWidth * healthPercent, barHeight);
                
                // Armor bar (if applicable)
                if (this.armor > 0) {
                    ctx.fillStyle = '#C0C0C0';
                    ctx.fillRect(this.x - barWidth/2, this.y - size - 8, barWidth, 2);
                }
            }
            
            takeDamage(damage) {
                let finalDamage = damage;
                
                // Apply armor reduction
                if (this.armor > 0) {
                    finalDamage = Math.max(1, damage - this.armor);
                }
                
                this.health -= finalDamage;
                
                if (this.health <= 0) {
                    game.gold += this.reward;
                    return true;
                }
                return false;
            }
        }
        
        // Game functions
        function selectTower(type) {
            // Check if trying to select hero when already placed
            if (type === 'hero' && game.heroPlaced) {
                return; // Can't select hero if already placed
            }

            if (game.gold >= towerTypes[type].baseCost) {
                game.selectedTowerType = type;
                game.selectedTowerInstance = null;
                deselectAllTowers();
                updateUI();
            }
        }
        
        function selectTowerInstance(tower) {
            game.selectedTowerType = null;
            game.selectedTowerInstance = tower;
            deselectAllTowers();
            tower.isSelected = true;
            updateUI();
        }
        
        function deselectTower() {
            game.selectedTowerType = null;
            game.selectedTowerInstance = null;
            deselectAllTowers();
            updateUI();
        }
        
        function deselectAllTowers() {
            for (let tower of towers) {
                tower.isSelected = false;
            }
        }
        
        function upgradeTower() {
            if (game.selectedTowerInstance && game.selectedTowerInstance.upgrade()) {
                updateUI();
            }
        }
        
        function sellTower() {
            if (game.selectedTowerInstance) {
                const tower = game.selectedTowerInstance;

                // Calculate sell value (50% of total investment)
                const baseCost = towerTypes[tower.type].baseCost;
                let totalInvestment = baseCost;

                // Add upgrade costs
                for (let i = 0; i < tower.level; i++) {
                    totalInvestment += Math.floor(baseCost * (1.5 ** (i + 1)));
                }

                const sellValue = Math.floor(totalInvestment * 0.5);

                // Remove tower and give gold
                const towerIndex = towers.indexOf(tower);
                if (towerIndex > -1) {
                    // Unmark hero if selling hero
                    if (tower.type === 'hero') {
                        game.heroPlaced = false;
                    }

                    towers.splice(towerIndex, 1);
                    game.gold += sellValue;
                    game.selectedTowerInstance = null;
                    updateUI();
                }
            }
        }
        
        function getTowerAt(x, y) {
            for (let tower of towers) {
                const distance = Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2);
                if (distance <= 20) {
                    return tower;
                }
            }
            return null;
        }
        
        function toggleAutoWave() {
            game.autoWave = document.getElementById('autoWaveToggle').checked;
            game.autoWaveCountdown = 0;
            
            // Update visual styling
            const container = document.getElementById('autoWaveContainer');
            const label = document.getElementById('autoWaveLabel');
            
            if (game.autoWave) {
                container.style.borderColor = '#4CAF50';
                container.style.background = 'rgba(76, 175, 80, 0.2)';
                label.textContent = 'üîÑ Auto-start waves (ON)';
                
                if (!game.waveActive && enemies.length === 0) {
                    game.autoWaveCountdown = 180; // 3 seconds countdown
                }
            } else {
                container.style.borderColor = 'transparent';
                container.style.background = 'rgba(0,0,0,0.3)';
                label.textContent = 'üîÑ Auto-start waves';
            }
            
            updateUI();
        }
        
        function updateAutoWave() {
            if (game.autoWave && !game.waveActive && enemies.length === 0) {
                if (game.autoWaveCountdown > 0) {
                    game.autoWaveCountdown--;
                    
                    // Update countdown display
                    const seconds = Math.ceil(game.autoWaveCountdown / 60);
                    document.getElementById('autoWaveStatus').textContent = 
                        `Auto-starting wave ${game.wave} in ${seconds} seconds...`;
                    
                    if (game.autoWaveCountdown === 0) {
                        startWave();
                    }
                } else {
                    // Start countdown for next wave
                    game.autoWaveCountdown = 180; // 3 seconds
                }
            }
        }
        
        function canPlaceTower(x, y) {
            // Check if too close to path (more thorough check)
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                
                // Check distance to path segment
                const A = x - p1.x;
                const B = y - p1.y;
                const C = p2.x - p1.x;
                const D = p2.y - p1.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                if (param < 0) {
                    xx = p1.x;
                    yy = p1.y;
                } else if (param > 1) {
                    xx = p2.x;
                    yy = p2.y;
                } else {
                    xx = p1.x + param * C;
                    yy = p1.y + param * D;
                }
                
                const dx = x - xx;
                const dy = y - yy;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 50) return false; // Increased from 40 to 50
            }
            
            // Check if too close to other towers
            for (let tower of towers) {
                const distance = Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2);
                if (distance < 40) return false;
            }
            
            return true;
        }
        
        function placeTower(x, y) {
            if (!game.selectedTowerType || !canPlaceTower(x, y)) return;

            const cost = towerTypes[game.selectedTowerType].baseCost;
            if (game.gold >= cost) {
                towers.push(new Tower(x, y, game.selectedTowerType));
                game.gold -= cost;

                // Mark hero as placed if it's a hero
                if (game.selectedTowerType === 'hero') {
                    game.heroPlaced = true;
                }

                game.selectedTowerType = null;
                updateUI();
            }
        }
        
        function startWave() {
            if (game.waveActive) return;
            
            game.waveActive = true;
            
            // Generate wave composition based on wave number
            const waveComposition = generateWaveComposition(game.wave);
            const totalEnemies = waveComposition.length;
            
            console.log(`Wave ${game.wave}: Spawning ${totalEnemies} enemies`, waveComposition);

            // Spawn enemies with varied timing
            for (let i = 0; i < totalEnemies; i++) {
                setTimeout(() => {
                    const enemyType = waveComposition[i];
                    enemies.push(new Enemy(enemyType, game.wave));
                }, i * (800 - Math.min(game.wave * 20, 400))); // Faster spawning in later waves
            }

            // Check for wave completion (immediate check, no delay)
            const checkWaveComplete = setInterval(() => {
                if (enemies.length === 0 && game.waveActive) {
                    game.wave++;
                    game.waveActive = false;
                    const bonus = 40 + (game.wave * 6); // Better wave completion bonus
                    game.gold += bonus;
                    
                    // Check for map progression
                    const mapChanged = checkMapProgression();
                    
                    // Start auto-wave countdown if enabled and no map change
                    if (game.autoWave && !mapChanged) {
                        game.autoWaveCountdown = 180; // 3 seconds
                    }
                    
                    clearInterval(checkWaveComplete);
                    updateUI();
                }
            }, 100);

            updateUI();
        }
        
        function getCurrentMap() {
            return mapData[game.currentMap] || mapData[mapData.length - 1];
        }
        
        function checkMapProgression() {
            const currentMapData = getCurrentMap();
            const waveInMap = ((game.wave - 1) % currentMapData.waves) + 1;

            // Check if we completed the final map (VICTORY!)
            if (waveInMap === currentMapData.waves && game.currentMap === mapData.length - 1) {
                game.victory = true;
                return true;
            }

            // Check if we completed a map (except the final castle map)
            if (waveInMap === currentMapData.waves && game.currentMap < mapData.length - 1) {
                game.currentMap++;
                showMapTransition();
                return true;
            }
            return false;
        }
        
        function showMapTransition() {
            const newMap = getCurrentMap();

            // Show transition message
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#FFD700';
            ctx.font = '36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('MAP COMPLETE!', canvas.width/2, canvas.height/2 - 60);

            ctx.fillStyle = '#FFFFFF';
            ctx.font = '24px Arial';
            ctx.fillText(newMap.name, canvas.width/2, canvas.height/2 - 10);

            ctx.font = '16px Arial';
            ctx.fillText(newMap.description, canvas.width/2, canvas.height/2 + 20);

            ctx.fillText('Press any key to continue...', canvas.width/2, canvas.height/2 + 60);
        }

        function showVictoryScreen() {
            // Clear canvas with dark background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add celebratory background effects
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
            gradient.addColorStop(0.5, 'rgba(76, 175, 80, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Main victory message
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('VICTORY!', canvas.width/2, canvas.height/2 - 120);

            // Castle emoji
            ctx.font = '80px Arial';
            ctx.fillText('üè∞', canvas.width/2, canvas.height/2 - 40);

            // Secondary message
            ctx.fillStyle = '#4CAF50';
            ctx.font = 'bold 32px Arial';
            ctx.fillText('The Kingdom Has Been Saved!', canvas.width/2, canvas.height/2 + 60);

            // Stats
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '20px Arial';
            ctx.fillText(`Waves Completed: ${game.wave - 1}`, canvas.width/2, canvas.height/2 + 110);
            ctx.fillText(`Gold Remaining: ${game.gold}`, canvas.width/2, canvas.height/2 + 140);
            ctx.fillText(`Lives Remaining: ${game.lives}`, canvas.width/2, canvas.height/2 + 170);

            // Celebration message
            ctx.fillStyle = '#FFD700';
            ctx.font = 'italic 18px Arial';
            ctx.fillText('The enemy forces have been defeated!', canvas.width/2, canvas.height/2 + 220);

            // Trophy emojis
            ctx.font = '32px Arial';
            ctx.fillText('üèÜ', canvas.width/2 - 100, canvas.height/2 + 280);
            ctx.fillText('‚≠ê', canvas.width/2 - 50, canvas.height/2 + 280);
            ctx.fillText('üéâ', canvas.width/2, canvas.height/2 + 280);
            ctx.fillText('‚≠ê', canvas.width/2 + 50, canvas.height/2 + 280);
            ctx.fillText('üèÜ', canvas.width/2 + 100, canvas.height/2 + 280);
        }
        
        function generateWaveComposition(wave) {
            const composition = [];
            const baseCount = 6 + Math.floor(wave * 1.5); // More enemies each wave
            
            // Wave progression logic
            if (wave <= 3) {
                // Early waves: mostly basic enemies
                for (let i = 0; i < baseCount; i++) {
                    composition.push(Math.random() < 0.8 ? 'basic' : 'fast');
                }
            } else if (wave <= 7) {
                // Mid-early waves: introduce variety
                for (let i = 0; i < baseCount; i++) {
                    const rand = Math.random();
                    if (rand < 0.4) composition.push('basic');
                    else if (rand < 0.7) composition.push('fast');
                    else composition.push('heavy');
                }
            } else if (wave <= 12) {
                // Mid waves: more dangerous enemies
                for (let i = 0; i < baseCount; i++) {
                    const rand = Math.random();
                    if (rand < 0.25) composition.push('basic');
                    else if (rand < 0.45) composition.push('fast');
                    else if (rand < 0.65) composition.push('heavy');
                    else composition.push('flying');
                }
            } else {
                // Late waves: all enemy types
                for (let i = 0; i < baseCount; i++) {
                    const rand = Math.random();
                    if (rand < 0.15) composition.push('basic');
                    else if (rand < 0.3) composition.push('fast');
                    else if (rand < 0.5) composition.push('heavy');
                    else composition.push('flying');
                }
            }
            
            // Always add a boss every 5th wave
            if (wave % 5 === 0) {
                composition.push('boss');
            }
            
            // Shuffle the composition for variety
            for (let i = composition.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [composition[i], composition[j]] = [composition[j], composition[i]];
            }
            
            return composition;
        }
        
        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                const dx = proj.targetX - proj.x;
                const dy = proj.targetY - proj.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < proj.speed) {
                    // Hit target
                    if (proj.target && enemies.includes(proj.target)) {
                        // Handle wind spell effect
                        if (proj.spellType === 'wind') {
                            // Push enemy all the way back to the beginning of the path!
                            proj.target.pathIndex = 0;
                            proj.target.x = path[0].x;
                            proj.target.y = path[0].y;

                            // Wind spell does normal damage and provides massive utility
                            const destroyed = proj.target.takeDamage(proj.damage);
                            if (destroyed) {
                                enemies.splice(enemies.indexOf(proj.target), 1);
                            }
                        } else {
                            // Normal damage
                            const destroyed = proj.target.takeDamage(proj.damage);
                            if (destroyed) {
                                enemies.splice(enemies.indexOf(proj.target), 1);
                            } else if (proj.fireDamage && proj.fireDamage > 0) {
                                // Apply fire damage over time from catapult
                                proj.target.burning = true;
                                proj.target.burnDamage = proj.fireDamage;
                                proj.target.burnDuration = 180; // 3 seconds at 60 fps
                            }
                        }
                    }
                    projectiles.splice(i, 1);
                } else {
                    proj.x += (dx / distance) * proj.speed;
                    proj.y += (dy / distance) * proj.speed;
                }
            }
        }
        
        // Cleaner decorative elements (no overlapping, better positioned)
        const decorations = [
            // Trees (positioned away from path and each other)
            { type: 'tree', x: 80, y: 80, size: 'large' },
            { type: 'tree', x: 720, y: 100, size: 'medium' },
            { type: 'tree', x: 100, y: 520, size: 'medium' },
            { type: 'tree', x: 650, y: 520, size: 'large' },
            { type: 'tree', x: 750, y: 300, size: 'small' },
            
            // Small water features (positioned carefully)
            { type: 'water', x: 250, y: 450, width: 60, height: 40 },
            { type: 'water', x: 580, y: 80, width: 50, height: 35 },
            
            // Flower patches (smaller, better spaced)
            { type: 'flowers', x: 150, y: 150, color: 'red' },
            { type: 'flowers', x: 400, y: 100, color: 'yellow' },
            { type: 'flowers', x: 200, y: 500, color: 'purple' },
            { type: 'flowers', x: 550, y: 450, color: 'pink' },
            { type: 'flowers', x: 680, y: 250, color: 'blue' },
            
            // Rocks (small decorative elements)
            { type: 'rock', x: 350, y: 480, size: 'small' },
            { type: 'rock', x: 450, y: 120, size: 'small' },
            { type: 'rock', x: 120, y: 350, size: 'small' }
        ];
        
        function drawDecorations() {
            for (let decoration of decorations) {
                switch(decoration.type) {
                    case 'tree':
                        drawTree(decoration.x, decoration.y, decoration.size);
                        break;
                    case 'water':
                        drawWater(decoration.x, decoration.y, decoration.width, decoration.height);
                        break;
                    case 'flowers':
                        drawFlowers(decoration.x, decoration.y, decoration.color);
                        break;
                    case 'rock':
                        drawRock(decoration.x, decoration.y, decoration.size);
                        break;
                }
            }
        }
        
        function drawTree(x, y, size) {
            let trunkHeight, trunkWidth, crownRadius;
            
            switch(size) {
                case 'large':
                    trunkHeight = 25;
                    trunkWidth = 8;
                    crownRadius = 20;
                    break;
                case 'medium':
                    trunkHeight = 20;
                    trunkWidth = 6;
                    crownRadius = 15;
                    break;
                case 'small':
                    trunkHeight = 15;
                    trunkWidth = 4;
                    crownRadius = 12;
                    break;
            }
            
            // Tree trunk
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - trunkWidth/2, y, trunkWidth, trunkHeight);
            
            // Tree crown (multiple circles for fuller look)
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(x, y - crownRadius/2, crownRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Additional crown layers for depth
            ctx.fillStyle = '#32CD32';
            ctx.beginPath();
            ctx.arc(x - crownRadius/3, y - crownRadius/3, crownRadius * 0.7, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.arc(x + crownRadius/4, y - crownRadius/4, crownRadius * 0.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawWater(x, y, width, height) {
            // Water body with gradient effect
            const gradient = ctx.createRadialGradient(x + width/2, y + height/2, 0, x + width/2, y + height/2, Math.max(width, height)/2);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.5, '#4682B4');
            gradient.addColorStop(1, '#191970');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(x + width/2, y + height/2, width/2, height/2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Static water highlights
            ctx.fillStyle = '#E0FFFF';
            ctx.beginPath();
            ctx.arc(x + width * 0.3, y + height * 0.3, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + width * 0.7, y + height * 0.6, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawFlowers(x, y, color) {
            const flowerColors = {
                red: ['#FF6B6B', '#FF4757'],
                yellow: ['#FFD93D', '#FFC312'],
                purple: ['#A55EEA', '#8B5CF6'],
                pink: ['#FF9FF3', '#F368E0'],
                blue: ['#74B9FF', '#0984E3']
            };
            
            const colors = flowerColors[color] || flowerColors.red;
            
            // Draw multiple small flowers in a patch (static positions)
            const flowerPositions = [
                {dx: 0, dy: 0}, {dx: -8, dy: -5}, {dx: 8, dy: -3}, 
                {dx: -5, dy: 8}, {dx: 6, dy: 7}
            ];
            
            for (let i = 0; i < 5; i++) {
                const flowerX = x + flowerPositions[i].dx;
                const flowerY = y + flowerPositions[i].dy;
                
                // Flower petals
                ctx.fillStyle = colors[0];
                for (let petal = 0; petal < 5; petal++) {
                    const angle = (petal * Math.PI * 2) / 5;
                    const petalX = flowerX + Math.cos(angle) * 4;
                    const petalY = flowerY + Math.sin(angle) * 4;
                    
                    ctx.beginPath();
                    ctx.arc(petalX, petalY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Flower center
                ctx.fillStyle = colors[1];
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Stem
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(flowerX, flowerY);
                ctx.lineTo(flowerX, flowerY + 8);
                ctx.stroke();
            }
        }
        
        function drawRock(x, y, size) {
            let rockSize = size === 'medium' ? 12 : 8;
            
            // Rock shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 2, y + rockSize + 2, rockSize * 0.8, rockSize * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Main rock
            ctx.fillStyle = '#696969';
            ctx.beginPath();
            ctx.arc(x, y, rockSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Rock highlight
            ctx.fillStyle = '#A9A9A9';
            ctx.beginPath();
            ctx.arc(x - rockSize/3, y - rockSize/3, rockSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawObjective() {
            const currentMapData = getCurrentMap();
            const endPoint = path[path.length - 1];
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            switch(currentMapData.objective) {
                case 'Bridge':
                    // Draw bridge structure
                    ctx.fillStyle = '#8B7355';
                    ctx.fillRect(endPoint.x - 30, endPoint.y - 15, 60, 30);
                    
                    // Bridge supports
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(endPoint.x - 25, endPoint.y - 10, 8, 20);
                    ctx.fillRect(endPoint.x + 17, endPoint.y - 10, 8, 20);
                    
                    // Bridge emoji
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '24px Arial';
                    ctx.fillText('üåâ', endPoint.x, endPoint.y - 30);
                    break;
                    
                case 'Pass':
                    // Draw mountain pass
                    ctx.fillStyle = '#8D6E63';
                    ctx.beginPath();
                    ctx.moveTo(endPoint.x - 40, endPoint.y + 20);
                    ctx.lineTo(endPoint.x - 20, endPoint.y - 30);
                    ctx.lineTo(endPoint.x + 20, endPoint.y - 30);
                    ctx.lineTo(endPoint.x + 40, endPoint.y + 20);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Mountain emoji
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '24px Arial';
                    ctx.fillText('üèîÔ∏è', endPoint.x, endPoint.y - 40);
                    break;
                    
                case 'Castle':
                    // Draw castle
                    ctx.fillStyle = '#757575';
                    ctx.fillRect(endPoint.x - 35, endPoint.y - 20, 70, 40);
                    
                    // Castle towers
                    ctx.fillRect(endPoint.x - 40, endPoint.y - 30, 15, 30);
                    ctx.fillRect(endPoint.x + 25, endPoint.y - 30, 15, 30);
                    
                    // Castle gate
                    ctx.fillStyle = '#424242';
                    ctx.fillRect(endPoint.x - 10, endPoint.y - 5, 20, 25);
                    
                    // Castle emoji
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '24px Arial';
                    ctx.fillText('üè∞', endPoint.x, endPoint.y - 45);
                    break;
            }
        }
        
        function drawPath() {
            const currentMapData = getCurrentMap();
            
            // Draw path background
            ctx.strokeStyle = currentMapData.pathColor;
            ctx.lineWidth = 40;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
            
            // Draw path center
            ctx.strokeStyle = currentMapData.pathCenterColor;
            ctx.lineWidth = 30;
            
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
        }
        
        function drawProjectiles() {
            for (let proj of projectiles) {
                // Catapult projectiles (rocks with optional fire)
                if (proj.towerType === 'catapult') {
                    // Draw rock
                    ctx.fillStyle = '#696969';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Add fire trail if it has fire damage
                    if (proj.fireDamage && proj.fireDamage > 0) {
                        ctx.fillStyle = '#FF4500';
                        ctx.beginPath();
                        ctx.arc(proj.x - 3, proj.y - 3, 4, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#FFA500';
                        ctx.beginPath();
                        ctx.arc(proj.x + 2, proj.y + 2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                // Different colors for different spell types
                else if (proj.spellType === 'wind') {
                    ctx.fillStyle = '#87CEEB'; // Sky blue for wind
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Add wind effect visual - more dramatic for powerful effect
                    ctx.strokeStyle = '#B0E0E6';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 12, 0, Math.PI * 2);
                    ctx.stroke();

                    // Add swirling wind lines
                    ctx.strokeStyle = '#87CEEB';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(proj.x, proj.y, 6 + (i * 3), 0, Math.PI * 1.5);
                        ctx.stroke();
                    }
                } else if (proj.spellType === 'fire') {
                    ctx.fillStyle = '#FF4500'; // Orange red for fire
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.spellType === 'ice') {
                    ctx.fillStyle = '#00BFFF'; // Deep sky blue for ice
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.spellType === 'lightning') {
                    ctx.fillStyle = '#FFFF00'; // Yellow for lightning
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#FFD700'; // Gold for normal projectiles
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function updateUI() {
            document.getElementById('goldDisplay').textContent = game.gold;
            document.getElementById('livesDisplay').textContent = game.lives;
            document.getElementById('waveDisplay').textContent = game.wave;
            document.getElementById('enemiesDisplay').textContent = enemies.length;
            
            // Update map display
            const currentMapData = getCurrentMap();
            const waveInMap = ((game.wave - 1) % currentMapData.waves) + 1;
            document.getElementById('mapDisplay').textContent = `${currentMapData.objective} (${waveInMap}/${currentMapData.waves})`;
            
            // Update tower buttons
            for (let type in towerTypes) {
                const button = document.getElementById(type + 'Tower');
                if (button) {
                    const cost = towerTypes[type].baseCost;

                    // Disable hero button if already placed
                    if (type === 'hero' && game.heroPlaced) {
                        button.disabled = true;
                        button.style.background = '#666';
                    } else {
                        button.disabled = game.gold < cost;
                        if (game.selectedTowerType === type) {
                            button.style.background = 'linear-gradient(45deg, #FFD700, #FFA500)';
                        } else {
                            button.style.background = game.gold >= cost ?
                                'linear-gradient(45deg, #4CAF50, #45a049)' : '#666';
                        }
                    }
                }
            }
            
            // Update upgrade section
            const upgradeSection = document.getElementById('upgradeSection');
            const upgradeButton = document.getElementById('upgradeButton');
            const selectedInfo = document.getElementById('selectedTowerInfo');
            
            if (game.selectedTowerInstance) {
                upgradeSection.style.display = 'block';
                const tower = game.selectedTowerInstance;
                const towerData = towerTypes[tower.type];
                
                // Calculate sell value for display
                const baseCost = towerTypes[tower.type].baseCost;
                let totalInvestment = baseCost;
                for (let i = 0; i < tower.level; i++) {
                    totalInvestment += Math.floor(baseCost * (1.5 ** (i + 1)));
                }
                const sellValue = Math.floor(totalInvestment * 0.5);
                
                selectedInfo.innerHTML = `
                    <strong>${towerData.name}</strong><br>
                    Level: ${tower.level + 1}/4<br>
                    Damage: ${tower.stats.damage}<br>
                    Range: ${tower.stats.range}<br>
                    Fire Rate: ${(1000/tower.stats.fireRate).toFixed(1)}/sec<br>
                    <span style="color: #FFD700;">Sell Value: ${sellValue}g</span>
                `;
                
                if (tower.canUpgrade()) {
                    upgradeButton.disabled = false;
                    upgradeButton.textContent = `Upgrade (${tower.getUpgradeCost()}g)`;
                    upgradeButton.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                } else {
                    upgradeButton.disabled = true;
                    upgradeButton.textContent = tower.level >= 3 ? 'Max Level' : 'Not Enough Gold';
                    upgradeButton.style.background = '#666';
                }
            } else {
                upgradeSection.style.display = 'none';
            }
            
            document.getElementById('waveButton').disabled = game.waveActive;
            
            // Update auto-wave status
            const autoWaveStatus = document.getElementById('autoWaveStatus');
            if (game.autoWave) {
                if (game.waveActive) {
                    autoWaveStatus.textContent = `Auto mode - Wave ${game.wave} in progress`;
                } else if (enemies.length > 0) {
                    autoWaveStatus.textContent = `Auto mode - Waiting for enemies to clear`;
                } else if (game.autoWaveCountdown > 0) {
                    const seconds = Math.ceil(game.autoWaveCountdown / 60);
                    autoWaveStatus.textContent = `Auto-starting wave ${game.wave} in ${seconds} seconds...`;
                } else {
                    autoWaveStatus.textContent = `Auto mode - Ready for wave ${game.wave}`;
                }
            } else {
                autoWaveStatus.textContent = `Manual mode - Click to start each wave`;
            }
        }
        
        function gameLoop() {
            // Clear canvas with map-specific background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const currentMapData = getCurrentMap();
            ctx.fillStyle = currentMapData.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw game elements
            drawDecorations(); // Draw scenery first (background)
            drawPath();
            drawObjective(); // Draw the thing we're protecting
            
            // Update and draw towers
            for (let tower of towers) {
                tower.update();
                tower.draw();
            }
            
            // Update and draw enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (!enemies[i].update()) {
                    enemies.splice(i, 1);
                } else {
                    enemies[i].draw();
                }
            }
            
            // Update and draw projectiles
            updateProjectiles();
            drawProjectiles();
            
            // Update auto-wave system
            updateAutoWave();
            
            // Update UI
            updateUI();

            // Check victory
            if (game.victory) {
                showVictoryScreen();
                return;
            }

            // Check game over
            if (game.lives <= 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#FF0000';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                return;
            }

            requestAnimationFrame(gameLoop);
        }
        
        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on existing tower
            const clickedTower = getTowerAt(x, y);
            if (clickedTower) {
                selectTowerInstance(clickedTower);
                return;
            }
            
            // Place new tower
            if (game.selectedTowerType) {
                placeTower(x, y);
            } else {
                deselectTower();
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (game.selectedTowerType) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                canvas.style.cursor = canPlaceTower(x, y) ? 'crosshair' : 'not-allowed';
            } else {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const tower = getTowerAt(x, y);
                
                canvas.style.cursor = tower ? 'pointer' : 'default';
            }
        });
        
        // Start game
        console.log('Game starting...');
        updateUI();
        gameLoop();
    </script>
</body>
</html>